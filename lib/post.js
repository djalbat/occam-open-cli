"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return post;
    }
});
const _stream = require("stream");
const _necessary = require("necessary");
const _configuration = require("./configuration");
const _response = require("./utilities/response");
const _status = require("./utilities/status");
const _messages = require("./messages");
const { getVersion } = _necessary.packageUtilities, { createPostRequest } = _necessary.requestUtilities, { OK_200_STATUS_CODE } = _necessary.statusCodes, { CONTENT_TYPE_HEADER } = _necessary.headers, { APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE } = _necessary.contentTypes;
function post(uri, json, callback) {
    const host = (0, _configuration.retrieveHost)(), query = {}, headers = {
        [CONTENT_TYPE_HEADER]: APPLICATION_JSON_CHARSET_UTF_8_CONTENT_TYPE
    }, version = getVersion(), content = JSON.stringify(json), versionString = version; ///
    Object.assign(json, {
        versionString
    });
    const postRequest = createPostRequest(host, uri, query, headers, (error, response)=>{
        if (error) {
            console.log(_messages.SERVER_FAILED_TO_RESPOND_ERROR_MESSAGE);
            return;
        }
        (0, _response.contentFromResponse)(response, (content)=>{
            let json = null;
            try {
                const jsonString = content; ///
                json = JSON.parse(jsonString);
            } catch (error) {
                if (error) {
                    console.log(_messages.SERVER_FAILED_TO_RESPOND_ERROR_MESSAGE);
                }
            }
            const { statusCode } = response;
            if (statusCode !== OK_200_STATUS_CODE) {
                const statusMessage = (0, _status.statusMessageFromStatusCode)(statusCode);
                console.log(`The server responded with '${statusMessage}'.`);
                const { messages = [] } = json;
                messages.forEach((message)=>{
                    console.log(message);
                });
                return;
            }
            callback(json);
        });
    });
    const readable = _stream.Readable.from(content);
    readable.pipe(postRequest);
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wb3N0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gXCJzdHJlYW1cIjtcbmltcG9ydCB7IGhlYWRlcnMsIGNvbnRlbnRUeXBlcywgc3RhdHVzQ29kZXMsIHJlcXVlc3RVdGlsaXRpZXMsIHBhY2thZ2VVdGlsaXRpZXMgfSBmcm9tIFwibmVjZXNzYXJ5XCI7XG5cbmltcG9ydCB7IHJldHJpZXZlSG9zdCB9IGZyb20gXCIuL2NvbmZpZ3VyYXRpb25cIjtcbmltcG9ydCB7IGNvbnRlbnRGcm9tUmVzcG9uc2UgfSBmcm9tIFwiLi91dGlsaXRpZXMvcmVzcG9uc2VcIjtcbmltcG9ydCB7IHN0YXR1c01lc3NhZ2VGcm9tU3RhdHVzQ29kZSB9IGZyb20gXCIuL3V0aWxpdGllcy9zdGF0dXNcIjtcbmltcG9ydCB7IFNFUlZFUl9GQUlMRURfVE9fUkVTUE9ORF9FUlJPUl9NRVNTQUdFIH0gZnJvbSBcIi4vbWVzc2FnZXNcIjtcblxuY29uc3QgeyBnZXRWZXJzaW9uIH0gPSBwYWNrYWdlVXRpbGl0aWVzLFxuICAgICAgeyBjcmVhdGVQb3N0UmVxdWVzdCB9ID0gcmVxdWVzdFV0aWxpdGllcyxcbiAgICAgIHsgT0tfMjAwX1NUQVRVU19DT0RFIH0gPSBzdGF0dXNDb2RlcyxcbiAgICAgIHsgQ09OVEVOVF9UWVBFX0hFQURFUiB9ID0gaGVhZGVycyxcbiAgICAgIHsgQVBQTElDQVRJT05fSlNPTl9DSEFSU0VUX1VURl84X0NPTlRFTlRfVFlQRSB9ID0gY29udGVudFR5cGVzO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwb3N0KHVyaSwganNvbiwgY2FsbGJhY2spIHtcbiAgY29uc3QgaG9zdCA9IHJldHJpZXZlSG9zdCgpLFxuICAgICAgICBxdWVyeSA9IHt9LFxuICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgIFsgQ09OVEVOVF9UWVBFX0hFQURFUiBdOiBBUFBMSUNBVElPTl9KU09OX0NIQVJTRVRfVVRGXzhfQ09OVEVOVF9UWVBFXG4gICAgICAgIH0sXG4gICAgICAgIHZlcnNpb24gPSBnZXRWZXJzaW9uKCksXG4gICAgICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShqc29uKSwgLy8vXG4gICAgICAgIHZlcnNpb25TdHJpbmcgPSB2ZXJzaW9uOyAgLy8vXG5cbiAgT2JqZWN0LmFzc2lnbihqc29uLCB7XG4gICAgdmVyc2lvblN0cmluZ1xuICB9KTtcblxuICBjb25zdCBwb3N0UmVxdWVzdCA9IGNyZWF0ZVBvc3RSZXF1ZXN0KGhvc3QsIHVyaSwgcXVlcnksIGhlYWRlcnMsIChlcnJvciwgcmVzcG9uc2UpID0+IHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKFNFUlZFUl9GQUlMRURfVE9fUkVTUE9ORF9FUlJPUl9NRVNTQUdFKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRlbnRGcm9tUmVzcG9uc2UocmVzcG9uc2UsIChjb250ZW50KSA9PiB7XG4gICAgICBsZXQganNvbiA9IG51bGw7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGpzb25TdHJpbmcgPSBjb250ZW50OyAvLy9cblxuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShqc29uU3RyaW5nKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFNFUlZFUl9GQUlMRURfVE9fUkVTUE9ORF9FUlJPUl9NRVNTQUdFKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHN0YXR1c0NvZGUgfSA9IHJlc3BvbnNlO1xuXG4gICAgICBpZiAoc3RhdHVzQ29kZSAhPT0gT0tfMjAwX1NUQVRVU19DT0RFKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1c01lc3NhZ2UgPSBzdGF0dXNNZXNzYWdlRnJvbVN0YXR1c0NvZGUoc3RhdHVzQ29kZSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coYFRoZSBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggJyR7c3RhdHVzTWVzc2FnZX0nLmApO1xuXG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZXMgPSBbXSB9ID0ganNvbjtcblxuICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2soanNvbik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGNvbnN0IHJlYWRhYmxlID0gUmVhZGFibGUuZnJvbShjb250ZW50KTtcblxuICByZWFkYWJsZS5waXBlKHBvc3RSZXF1ZXN0KTtcbn1cbiJdLCJuYW1lcyI6WyJwb3N0IiwiZ2V0VmVyc2lvbiIsInBhY2thZ2VVdGlsaXRpZXMiLCJjcmVhdGVQb3N0UmVxdWVzdCIsInJlcXVlc3RVdGlsaXRpZXMiLCJPS18yMDBfU1RBVFVTX0NPREUiLCJzdGF0dXNDb2RlcyIsIkNPTlRFTlRfVFlQRV9IRUFERVIiLCJoZWFkZXJzIiwiQVBQTElDQVRJT05fSlNPTl9DSEFSU0VUX1VURl84X0NPTlRFTlRfVFlQRSIsImNvbnRlbnRUeXBlcyIsInVyaSIsImpzb24iLCJjYWxsYmFjayIsImhvc3QiLCJyZXRyaWV2ZUhvc3QiLCJxdWVyeSIsInZlcnNpb24iLCJjb250ZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsInZlcnNpb25TdHJpbmciLCJPYmplY3QiLCJhc3NpZ24iLCJwb3N0UmVxdWVzdCIsImVycm9yIiwicmVzcG9uc2UiLCJjb25zb2xlIiwibG9nIiwiU0VSVkVSX0ZBSUxFRF9UT19SRVNQT05EX0VSUk9SX01FU1NBR0UiLCJjb250ZW50RnJvbVJlc3BvbnNlIiwianNvblN0cmluZyIsInBhcnNlIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJzdGF0dXNNZXNzYWdlRnJvbVN0YXR1c0NvZGUiLCJtZXNzYWdlcyIsImZvckVhY2giLCJtZXNzYWdlIiwicmVhZGFibGUiLCJSZWFkYWJsZSIsImZyb20iLCJwaXBlIl0sIm1hcHBpbmdzIjoiQUFBQTs7OzsrQkFnQkE7OztlQUF3QkE7Ozt3QkFkQzsyQkFDOEQ7K0JBRTFEOzBCQUNPO3dCQUNROzBCQUNXO0FBRXZELE1BQU0sRUFBRUMsVUFBVSxFQUFFLEdBQUdDLDJCQUFnQixFQUNqQyxFQUFFQyxpQkFBaUIsRUFBRSxHQUFHQywyQkFBZ0IsRUFDeEMsRUFBRUMsa0JBQWtCLEVBQUUsR0FBR0Msc0JBQVcsRUFDcEMsRUFBRUMsbUJBQW1CLEVBQUUsR0FBR0Msa0JBQU8sRUFDakMsRUFBRUMsMkNBQTJDLEVBQUUsR0FBR0MsdUJBQVk7QUFFckQsU0FBU1YsS0FBS1csR0FBRyxFQUFFQyxJQUFJLEVBQUVDLFFBQVE7SUFDOUMsTUFBTUMsT0FBT0MsSUFBQUEsMkJBQVksS0FDbkJDLFFBQVEsQ0FBQyxHQUNUUixVQUFVO1FBQ1IsQ0FBRUQsb0JBQXFCLEVBQUVFO0lBQzNCLEdBQ0FRLFVBQVVoQixjQUNWaUIsVUFBVUMsS0FBS0MsU0FBUyxDQUFDUixPQUN6QlMsZ0JBQWdCSixTQUFVLEdBQUc7SUFFbkNLLE9BQU9DLE1BQU0sQ0FBQ1gsTUFBTTtRQUNsQlM7SUFDRjtJQUVBLE1BQU1HLGNBQWNyQixrQkFBa0JXLE1BQU1ILEtBQUtLLE9BQU9SLFNBQVMsQ0FBQ2lCLE9BQU9DO1FBQ3ZFLElBQUlELE9BQU87WUFDVEUsUUFBUUMsR0FBRyxDQUFDQyxnREFBc0M7WUFFbEQ7UUFDRjtRQUVBQyxJQUFBQSw2QkFBbUIsRUFBQ0osVUFBVSxDQUFDUjtZQUM3QixJQUFJTixPQUFPO1lBRVgsSUFBSTtnQkFDRixNQUFNbUIsYUFBYWIsU0FBUyxHQUFHO2dCQUUvQk4sT0FBT08sS0FBS2EsS0FBSyxDQUFDRDtZQUNwQixFQUFFLE9BQU9OLE9BQU87Z0JBQ2QsSUFBSUEsT0FBTztvQkFDVEUsUUFBUUMsR0FBRyxDQUFDQyxnREFBc0M7Z0JBQ3BEO1lBQ0Y7WUFFQSxNQUFNLEVBQUVJLFVBQVUsRUFBRSxHQUFHUDtZQUV2QixJQUFJTyxlQUFlNUIsb0JBQW9CO2dCQUNyQyxNQUFNNkIsZ0JBQWdCQyxJQUFBQSxtQ0FBMkIsRUFBQ0Y7Z0JBRWxETixRQUFRQyxHQUFHLENBQUMsQ0FBQywyQkFBMkIsRUFBRU0sY0FBYyxFQUFFLENBQUM7Z0JBRTNELE1BQU0sRUFBRUUsV0FBVyxFQUFFLEVBQUUsR0FBR3hCO2dCQUUxQndCLFNBQVNDLE9BQU8sQ0FBQyxDQUFDQztvQkFDaEJYLFFBQVFDLEdBQUcsQ0FBQ1U7Z0JBQ2Q7Z0JBRUE7WUFDRjtZQUVBekIsU0FBU0Q7UUFDWDtJQUNGO0lBRUEsTUFBTTJCLFdBQVdDLGdCQUFRLENBQUNDLElBQUksQ0FBQ3ZCO0lBRS9CcUIsU0FBU0csSUFBSSxDQUFDbEI7QUFDaEIifQ==